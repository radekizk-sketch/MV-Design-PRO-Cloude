"""
SLD Result Overlay Builder.

PowerFactory Alignment (per sld_rules.md § B, powerfactory_ui_parity.md § B.2):
- Results are OVERLAY only, never written to model
- result_status: NONE, FRESH, OUTDATED
- Overlay visible only in RESULT_VIEW mode
- OUTDATED results → grayed or hidden per powerfactory_ui_parity.md

PCC (Point of Common Coupling) identification is handled by Analysis layer
(BoundaryIdentifier), not by this overlay builder.
"""

from __future__ import annotations

from enum import Enum
from typing import Any


class ResultStatus(str, Enum):
    """
    Result freshness status (per powerfactory_ui_parity.md § B.2).

    NONE: Never computed
    FRESH: Results current with model
    OUTDATED: Model changed since computation
    """

    NONE = "NONE"
    FRESH = "FRESH"
    OUTDATED = "OUTDATED"


class ResultSldOverlayBuilder:
    """
    Builds result overlays for SLD visualization.

    Per sld_rules.md § B.1-B.3:
    - Results displayed as overlay, not symbol modifications
    - Overlay generated by Analysis layer, not Solver
    - No results written to NetworkModel

    Per sld_rules.md § F.4 (Converter Sources Overlay):
    - P, Q, I values with direction
    - Result freshness status included
    """

    def build_short_circuit_overlay(
        self,
        sld_payload: dict[str, Any] | None,
        result_payload: dict[str, Any] | None,
        result_status: ResultStatus = ResultStatus.NONE,
    ) -> dict[str, Any]:
        """
        Build short-circuit result overlay.

        Args:
            sld_payload: SLD diagram payload with nodes/branches/switches
            result_payload: Short-circuit result data
            result_status: Freshness status (NONE, FRESH, OUTDATED)

        Returns:
            Overlay dict with nodes, branches, switches arrays and status
        """
        overlay: dict[str, Any] = {
            "nodes": [],
            "branches": [],
            "switches": [],
            "result_status": result_status.value,
        }

        if not sld_payload or not result_payload:
            return overlay

        fault_node_id = result_payload.get("fault_node_id")
        if fault_node_id is None:
            return overlay

        metrics = {
            "ik_a": result_payload.get("ikss_a") or result_payload.get("ik_a"),
            "ib_a": result_payload.get("ib_a"),
            "sz_mva": result_payload.get("sk_mva") or result_payload.get("sz_mva"),
        }
        metrics = {key: value for key, value in metrics.items() if value is not None}
        if not metrics:
            return overlay

        for node in sld_payload.get("nodes", []):
            if str(node.get("node_id")) != str(fault_node_id):
                continue
            overlay["nodes"].append({"node_id": node.get("node_id"), **metrics})
            break

        return overlay

    def build_power_flow_overlay(
        self,
        sld_payload: dict[str, Any] | None,
        result_payload: dict[str, Any] | None,
        result_status: ResultStatus = ResultStatus.NONE,
    ) -> dict[str, Any]:
        """
        Build power flow result overlay.

        Per sld_rules.md § F.4 (Converter Sources Overlay):
        - P (MW), Q (Mvar), I (A) values
        - Direction indicator (→ / ←)
        """
        overlay: dict[str, Any] = {
            "nodes": [],
            "branches": [],
            "switches": [],
            "sources": [],
            "result_status": result_status.value,
        }

        if not sld_payload or not result_payload:
            return overlay

        # Extract bus voltages
        bus_results = result_payload.get("bus_results", {})
        for node in sld_payload.get("nodes", []):
            node_id = str(node.get("node_id"))
            if node_id in bus_results:
                bus_data = bus_results[node_id]
                overlay["nodes"].append({
                    "node_id": node_id,
                    "v_pu": bus_data.get("v_pu"),
                    "v_kv": bus_data.get("v_kv"),
                    "angle_deg": bus_data.get("angle_deg"),
                })

        # Extract branch flows
        branch_results = result_payload.get("branch_results", {})
        for branch in sld_payload.get("branches", []):
            branch_id = str(branch.get("branch_id"))
            if branch_id in branch_results:
                branch_data = branch_results[branch_id]
                overlay["branches"].append({
                    "branch_id": branch_id,
                    "p_mw": branch_data.get("p_mw"),
                    "q_mvar": branch_data.get("q_mvar"),
                    "i_a": branch_data.get("i_a"),
                    "loading_percent": branch_data.get("loading_percent"),
                })

        return overlay
